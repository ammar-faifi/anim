import gettext
from functools import partial
from pathlib import Path

import numpy as np
from manim import *

# from manimlib import *

AR_PREAMBLE = r"""
\usepackage[utf8]{inputenc}
\usepackage{arabtex}
\usepackage[arabic]{babel}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{kpfonts}
"""


# Setup translation with its domain
languages = ["en"]
localedir = Path(__file__).parent / "locale"
t = gettext.translation("messages", localedir, languages, fallback=True)
_ = t.gettext
# right to left lang ?
IS_RTL = False

# For Arabic LaTeX
# config.tex_template = TexTemplate(preamble=AR_PREAMBLE)
config.background_color = GRAY_E


def create_square_glow(vmobject, length: float = 1, color=YELLOW):
    glow_group = VGroup()

    for idx in range(50):
        glow_group.add(
            Cube(
                length * (1.01**idx),
                stroke_opacity=0,
                fill_color=color,
                fill_opacity=0.006 - idx / 10_000,
            ).move_to(vmobject)
        )

    return glow_group


def create_glow(vmobject, rad=1, col=YELLOW):
    glow_group = VGroup()

    for idx in range(60):
        glow_group.add(
            Circle(
                radius=rad * (1.002 ** (idx**2)) / 400,
                stroke_opacity=0,
                fill_color=col,
                fill_opacity=0.2 - idx / 300,
            ).move_to(vmobject)
        )

    return glow_group


# Constants
k_B = 1.380649e-23  # Boltzmann constant
c = 2.998e8  # Speed of light


def rayleigh_jeans(wavelength, temperature):
    # with scaling to kW
    return (2 * c * k_B * temperature) / (wavelength**4) * 1e-12


def planck_spectral_radiance(wavelength, temperature):
    """
    Calculate spectral radiance using Planck's law.

    B(λ,T) = (2hc²/λ⁵) × 1/(exp(hc/λkT) - 1)

    Parameters:
    -----------
    wavelength : float or array
        Wavelength in meters
    temperature : float
        Temperature in Kelvin

    Returns:
    --------
    float or array : Spectral radiance in W⋅sr⁻¹⋅m⁻³
    """
    # Physical constants
    h = 6.62607015e-34  # Planck constant (J⋅s)
    c = 299792458  # Speed of light (m/s)
    k_B = 1.380649e-23  # Boltzmann constant (J/K)

    # Avoid division by zero and overflow
    exponent = (h * c) / (wavelength * k_B * temperature)

    # Use np.clip to avoid overflow in exponential
    exponent = np.clip(exponent, 0, 700)  # e^700 is near float64 limit

    numerator = 2 * h * c**2 / (wavelength**5)
    denominator = np.expm1(exponent)  # expm1(x) = exp(x) - 1, more accurate for small x

    return numerator / denominator


def planck_spectral_radiance_normalized(wavelength, temperature, scale_factor=1e-12):
    """
    Calculate normalized spectral radiance for better visualization.

    Parameters:
    -----------
    wavelength : float or array
        Wavelength in meters
    temperature : float
        Temperature in Kelvin
    scale_factor : float
        Scaling factor for the output (default: 1e-12 for kW units)

    Returns:
    --------
    float or array : Scaled spectral radiance
    """
    return planck_spectral_radiance(wavelength, temperature) * scale_factor


def planck_function_nm(wavelength_nm, temperature, scale_factor=1e-12):

    wavelength_m = wavelength_nm * 1e-9  # Convert nm to meters
    return planck_spectral_radiance_normalized(wavelength_m, temperature, scale_factor)


def wien_displacement_law(temperature):
    """
    Calculate peak wavelength using Wien's displacement law.

    λ_max = b / T, where b = 2.897771955×10⁻³ m⋅K

    Parameters:
    -----------
    temperature : float
        Temperature in Kelvin

    Returns:
    --------
    tuple : (peak_wavelength_m, peak_wavelength_nm)
    """
    wien_constant = 2.897771955e-3  # Wien's displacement constant (m⋅K)
    peak_wavelength_m = wien_constant / temperature
    peak_wavelength_nm = peak_wavelength_m * 1e9
    return peak_wavelength_m, peak_wavelength_nm


def stefan_boltzmann_law(temperature):
    """
    Calculate total radiated power using Stefan-Boltzmann law.

    j* = σT⁴, where σ = 5.670374419×10⁻⁸ W⋅m⁻²⋅K⁻⁴

    Parameters:
    -----------
    temperature : float
        Temperature in Kelvin

    Returns:
    --------
    float : Total radiated power per unit area (W⋅m⁻²)
    """
    stefan_boltzmann_constant = 5.670374419e-8  # W⋅m⁻²⋅K⁻⁴
    return stefan_boltzmann_constant * temperature**4


def get_wavelength_array(wavelength_range_nm=(200, 3000), num_points=1000):
    """
    Generate wavelength array for plotting.

    Parameters:
    -----------
    wavelength_range_nm : tuple
        Wavelength range in nanometers (min, max)
    num_points : int
        Number of points

    Returns:
    --------
    array : Wavelength array in nanometers
    """
    return np.linspace(wavelength_range_nm[0], wavelength_range_nm[1], num_points)


def find_wien_displacement_peak(temperature):
    """
    Find the wavelength of maximum emission using Wien's displacement law.

    λ_max = b / T, where b = 2.897771955×10⁻³ m⋅K

    Parameters:
    -----------
    temperature : float
        Temperature in Kelvin

    Returns:
    --------
    float : Peak wavelength in meters
    """
    wien_constant = 2.897771955e-3  # Wien's displacement constant (m⋅K)
    return wien_constant / temperature


class Introduction(ThreeDScene):
    """
    # Points to mention:
        - black body
            - what is the problem
            - what was the solution
            - Rayleigh–Jeans law
            - Rayleigh–Stefan law
            - Wein law
        - how is this trigger the idea of qunta
        - Eienstin's naming photons
        - Later, Hydrogen atom's qunatization of its energy level
        - Bohr's role

    # Visuals:
        - A black body cavity radiating
        - plot raylegh-Jean for different temp
        - show the infinite dillema
        - show the law's equation
    """

    def construct(self):
        self.next_section(skip_animations=True)

        title = Title(_("How was Quantum Physics started?"))
        sub_title = Title(_("Black body"))

        this_vid_topics = BulletedList(
            _("Black body."),
            _("Black body radiation."),
            _("Ultraviolet catastrophe."),
            _("Photons."),
            _("Quanta."),
        )

        self.play(Write(title, reverse=True, remover=False))

        for l in this_vid_topics:
            self.play(Write(l, reverse=IS_RTL, remover=False))

        self.play(this_vid_topics.animate.fade_all_but(0))

        self.play(Transform(title, sub_title))
        self.play(FadeOut(this_vid_topics))

        paul_portrait = ImageMobject("./figures/Paul_Ehrenfest.jpg")
        paul_name = Text(_("Paul Ehrenfest")).next_to(paul_portrait, DOWN)
        self.play(FadeIn(paul_portrait))
        self.wait()
        self.play(Write(paul_name, reverse=IS_RTL, remover=False))
        self.play(FadeOut(paul_portrait), Uncreate(paul_name))
        self.wait()

        bb_facts = BulletedList(
            _("It absorbs all light completely."),
            _("It radiates electromagnetic waves base on its temp."),
        )

        for l in bb_facts:
            self.play(Write(l, reverse=IS_RTL, remover=False))

        self.play(bb_facts.animate.fade_all_but(1))
        self.wait()
        self.play(FadeOut(bb_facts))

        axes = (
            Axes(
                x_range=[1, 3000, 100],
                y_range=[0, 20, 2],
                axis_config={"color": WHITE},
                x_axis_config={
                    "numbers_to_include": [0, 3000, 100],
                    "numbers_with_elongated_ticks": [0, 3000, 100],
                },
                y_axis_config={
                    "numbers_to_include": [0, 20, 2],
                    "numbers_with_elongated_ticks": [0, 20, 2],
                },
                tips=False,
            )
            .scale(0.6)
            .shift(DOWN + RIGHT)
        )

        # Labels
        x_label = axes.get_x_axis_label(r"\lambda [m]")
        y_label = axes.get_y_axis_label(
            r"Spectral Radiance\\(kW\cdot sr^{-1}\cdot m^{-3})"
        )
        labels = VGroup(x_label, y_label)
        labels.scale(0.5)

        # Visible spectrum range (380nm to 750nm)
        visible_range = Rectangle(
            width=axes.x_axis.unit_size * (750 - 380),
            height=4,
            fill_opacity=0.7,
            stroke_width=0,
        )
        visible_range.move_to(axes.c2p((380 + 750) / 2, 0, 0), aligned_edge=DOWN)
        colors = [GRAY_E, PURPLE, BLUE, GREEN, YELLOW, RED, GRAY_E]
        visible_range.set_color_by_gradient(colors)
        visible_range.set_sheen_direction(RIGHT)

        # Create graphs for different temperatures
        temperatures = [3000, 4000, 5000]
        graphs = VGroup()
        temp_labels = VGroup()

        for temp in temperatures:
            wavelengths = np.linspace(1100e-9, 3000e-9, 100)
            spectral_radiance = [rayleigh_jeans(w, temp) for w in wavelengths]

            graph = axes.plot_line_graph(
                x_values=wavelengths * 1e9,
                y_values=spectral_radiance,
                line_color=BLUE,
                add_vertex_dots=False,
            )

            temp_label = Text(f"{temp}K", font_size=24, color=BLUE_A)
            temp_label.next_to(graph, RIGHT)

            graphs.add(graph)
            temp_labels.add(temp_label)

        # Visible spectrum label
        visible_label = Text(_("Visible Spectrum"), font_size=24)
        visible_label.next_to(visible_range, UP)

        # Create the black body cube
        cube = Cube(
            side_length=2,
            fill_color=BLACK,
            fill_opacity=0.75,
            stroke_color=DARK_GRAY,
            stroke_width=1,
            stroke_opacity=1,
        )
        cube.set_shade_in_3d(True)
        glow_cube = create_square_glow(cube, 2).set_z_index(100)
        black_body = VGroup(glow_cube, cube).to_edge(LEFT)
        # black_body.rotate(PI / 2, RIGHT)

        # Animation sequence
        self.play(Create(axes), Write(labels))
        self.wait()

        self.play(FadeIn(visible_range), Write(visible_label))
        self.wait()

        for graph, label in zip(graphs, temp_labels):
            self.play(Create(graph), Write(label), run_time=1.5)
            self.wait(0.5)

        # Simulate temperature changes with color shifts
        temperatures = [1000, 2000, 3000, 4000, 5500]
        colors = ["#FF0017", "#FF7C00", "#CEB04D", "#83B28D", "#3DA8AD"]

        self.next_section()

        graph = axes.plot(partial(planck_function_nm, temperature=1000))
        self.add(axes, graph)

        self.play(FadeIn(black_body[1]))
        self.play(FadeIn(black_body[0]))
        # self.play(Rotate(black_body, axis=UP), run_time=4)

        for temp, color in zip(temperatures[1:], colors[1:]):
            new_temp_value = Text(f"{temp} K", font_size=28, color=color)
            # new_temp_value.move_to(temp_value.get_center())

            # new_glow_cube = create_square_glow(cube, 2.01, color=color)
            # new_glow_cube.move_to(glow_cube.get_center())

            self.play(
                # Transform(temp_value, new_temp_value),
                # Transform(black_body[0], new_glow_cube),
                Transform(
                    graph, axes.plot(partial(planck_function_nm, temperature=temp))
                ),
                black_body[0].animate.set_color(color),
                run_time=1.5,
            )
            self.wait(0.5)
            black_body[0].set_z_index(100)

        self.wait(2)


class RayleighJeansCatastrophe(Scene):
    def construct(self):
        axes = (
            Axes(
                x_range=[0, 3e-6, 0.5e-6],
                y_range=[0, 5e13, 1e13],
                axis_config={"color": WHITE},
                x_axis_config={
                    "numbers_to_include": np.arange(0, 3.5e-6, 0.5e-6),
                    "numbers_with_elongated_ticks": np.arange(0, 3.5e-6, 0.5e-6),
                },
                # y_axis_config={
                #     "numbers_to_include": np.arange(0, 6e13, 1e13),
                #     "numbers_with_elongated_ticks": np.arange(0, 6e13, 1e13),
                # },
                tips=False,
            )
            .scale(0.7)
            .shift(DOWN)
        )

        # Labels
        x_label = axes.get_x_axis_label(r"\lambda (m)")
        y_label = axes.get_y_axis_label(
            r"Spectral Radiance\\(W\cdot sr^{-1}\cdot m^{-3})"
        )
        labels = VGroup(x_label, y_label)
        labels.scale(0.5)

        # Title
        title = Text("Rayleigh-Jeans Catastrophe", font_size=40)
        title.to_edge(UP)

        # Visible spectrum range (380nm to 750nm)
        visible_range = Rectangle(
            width=axes.x_axis.unit_size * (750e-9 - 380e-9),
            height=4,
            fill_opacity=0.8,
            stroke_width=0,
        )
        visible_range.move_to(axes.c2p((380e-9 + 750e-9) / 2, 0, 0), aligned_edge=DOWN)
        colors = [PURPLE, BLUE, GREEN, YELLOW, RED]
        visible_range.set_color_by_gradient(colors)
        visible_range.set_sheen_direction(RIGHT)

        # Create graphs for different temperatures
        temperatures = [3000, 4000, 5000]
        graphs = VGroup()
        temp_labels = VGroup()

        for i, temp in enumerate(temperatures):
            wavelengths = np.linspace(1e-7, 3e-6, 1000)
            spectral_radiance = [rayleigh_jeans(w, temp) for w in wavelengths]

            graph = axes.plot_line_graph(
                x_values=wavelengths, y_values=spectral_radiance, line_color=BLUE
            )

            temp_label = Text(f"{temp}K", font_size=24, color=BLUE_A)
            temp_label.next_to(graph, RIGHT)

            graphs.add(graph)
            temp_labels.add(temp_label)

        # Visible spectrum label
        visible_label = Text("Visible Spectrum", font_size=24)
        visible_label.next_to(visible_range, UP)

        # Animation sequence
        self.play(Write(title))
        self.play(Create(axes), Write(labels))
        self.wait()

        self.play(FadeIn(visible_range), Write(visible_label))
        self.wait()

        # for graph, label in zip(graphs, temp_labels):
        #     self.play(Create(graph), Write(label), run_time=1.5)
        #     self.wait(0.5)
        #
        self.wait(2)


# Alternative version with temperature visualization
class BlackBodyWithTemperature(ThreeDScene):
    def construct(self):
        # Create the black body cube
        cube = Cube(
            side_length=2.5,
            fill_color=BLACK,
            fill_opacity=0.95,
            stroke_color=DARK_GRAY,
            stroke_width=1,
            stroke_opacity=0.4,
        )
        cube.set_shade_in_3d(True)

        # Create a subtle glow effect around the cube
        glow_cube = Cube(
            side_length=2.6, fill_color=RED, fill_opacity=0.1, stroke_width=0
        )
        glow_cube = create_square_glow(cube, 1.7)

        # Group cube and glow
        black_body = VGroup(glow_cube, cube)

        # Title and labels
        title = Text("Black Body at Different Temperatures", font_size=36, color=WHITE)
        title.to_edge(UP, buff=0.5)

        # Temperature indicator
        temp_text = Text("Temperature: ", font_size=28, color=WHITE)
        temp_value = Text("1000 K", font_size=28, color=YELLOW)
        temp_group = VGroup(temp_text, temp_value)
        temp_group.arrange(RIGHT, buff=0.2)
        temp_group.to_edge(DOWN, buff=1)

        # Set 3D camera
        # self.set_camera_orientation(phi=70 * DEGREES, theta=45 * DEGREES)

        # Animations
        self.play(Write(title), run_time=1.5)
        self.play(FadeIn(black_body[1]), Write(temp_group))
        self.play(FadeIn(black_body[0]))

        state = self.camera.get_phi(), self.camera.get_theta()
        self.move_camera(phi=45 * DEGREES, theta=-50 * DEGREES)
        self.wait(1)

        # Final rotation
        self.play(Rotate(black_body), run_time=3)

        # Simulate temperature changes with color shifts
        temperatures = [1000, 2000, 3000, 5000, 8000]
        colors = [0xFF0017, 0xFF7C00, 0xCEB04D, 0x83B28D, 0x3DA8AD]

        for temp, color in zip(temperatures[1:], colors[1:]):
            new_temp_value = Text(f"{temp} K", font_size=28, color=color)
            new_temp_value.move_to(temp_value.get_center())

            new_glow_cube = Cube(
                side_length=2.6, fill_color=color, fill_opacity=0.15, stroke_width=0
            )
            new_glow_cube = create_square_glow(cube, 1.7, color=color)
            new_glow_cube.move_to(glow_cube.get_center())

            self.play(
                Transform(temp_value, new_temp_value),
                black_body[0].animate.set_color(color),
                run_time=1.5,
            )
            self.wait(0.5)

        self.wait(2)

        # self.move_camera(phi=-45 * DEGREES, theta=50 * DEGREES)
        self.move_camera(*state)
        self.camera
        self.wait(1)
